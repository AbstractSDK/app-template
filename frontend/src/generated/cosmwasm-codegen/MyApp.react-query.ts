/**
* This file was automatically generated by @abstract-money/ts-codegen@0.35.5.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @abstract-money/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@abstract-money/cli/cosmjs";
import { StdFee, Coin } from "@abstract-money/cli/cosmjs";
import { ExecuteMsg, BaseExecuteMsg, MyAppExecuteMsg, Binary, CallbackResult, QueryRequestForEmpty, BankQuery, StakingQuery, DistributionQuery, IbcQuery, WasmQuery, ResultOfArrayOfBinaryOrErrorResponse, Uint64, ResultOfExecutionResponseOrString, ChainName, Namespace, ModuleVersion, IbcResponseMsg, PageRequest, Empty, ErrorResponse, ExecutionResponse, SubMsgResponse, Event, Attribute, ModuleIbcMsg, ModuleInfo, Addr, InstantiateMsg, BaseInstantiateMsg, AccountBase, MyAppInstantiateMsg, MigrateMsg, BaseMigrateMsg, MyAppMigrateMsg, QueryMsg, BaseQueryMsg, MyAppQueryMsg } from "./MyApp.types";
import { MyAppAppQueryClient, MyAppAppClient } from "./MyApp.client";
export const myAppQueryKeys = {
  contract: ([{
    contract: "myApp"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...myAppQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  base: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...myAppQueryKeys.address(contractAddress)[0],
    method: "base",
    args
  }] as const),
  module: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...myAppQueryKeys.address(contractAddress)[0],
    method: "module",
    args
  }] as const)
};
export interface MyAppReactQuery<TResponse, TData = TResponse> {
  client: MyAppAppQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface MyAppModuleQuery<TData> extends MyAppReactQuery<ModuleResponse, TData> {}
export function useMyAppModuleQuery<TData = ModuleResponse>({
  client,
  options
}: MyAppModuleQuery<TData>) {
  return useQuery<ModuleResponse, Error, TData>(myAppQueryKeys.module(client?._moduleAddress), () => client ? client.module() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MyAppBaseQuery<TData> extends MyAppReactQuery<BaseResponse, TData> {}
export function useMyAppBaseQuery<TData = BaseResponse>({
  client,
  options
}: MyAppBaseQuery<TData>) {
  return useQuery<BaseResponse, Error, TData>(myAppQueryKeys.base(client?._moduleAddress), () => client ? client.base() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface MyAppReceiveMutation {
  client: MyAppAppClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useMyAppReceiveMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, MyAppReceiveMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, MyAppReceiveMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receive(msg, fee, memo, funds), options);
}
export interface MyAppModuleIbcMutation {
  client: MyAppAppClient;
  msg: {
    clientChain: ChainName;
    msg: Binary;
    sourceModule: ModuleInfo;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useMyAppModuleIbcMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, MyAppModuleIbcMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, MyAppModuleIbcMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.moduleIbc(msg, fee, memo, funds), options);
}
export interface MyAppIbcCallbackMutation {
  client: MyAppAppClient;
  msg: {
    id: string;
    msg?: Binary;
    result: CallbackResult;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useMyAppIbcCallbackMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, MyAppIbcCallbackMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, MyAppIbcCallbackMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.ibcCallback(msg, fee, memo, funds), options);
}
export interface MyAppModuleMutation {
  client: MyAppAppClient;
  msg: MyAppExecuteMsg;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useMyAppModuleMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, MyAppModuleMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, MyAppModuleMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.module(msg, fee, memo, funds), options);
}
export interface MyAppBaseMutation {
  client: MyAppAppClient;
  msg: BaseExecuteMsg;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useMyAppBaseMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, MyAppBaseMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, MyAppBaseMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.base(msg, fee, memo, funds), options);
}